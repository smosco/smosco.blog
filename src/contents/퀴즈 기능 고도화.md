---
title: 'BIENGUAL: 퀴즈 기능 고도화'
date: 2024-11-20 11:01:12
category: developments
thumbnail: '/images/thumbnail/quiz.jpg'
draft: false
---

CNN 뉴스와 YouTube 콘텐츠 기반으로 학습 퀴즈를 제공하는 기능을 개발했습니다. 기존 상태 관리 방식에서 발생한 문제를 해결하기 위해 **이벤트 기반 설계**를 도입했습니다.

---

## 문제 정의

### 스냅샷 중심 상태 관리의 한계

- `isCorrect`로 상태를 관리했지만, 정답을 맞춘 즉시 `isCorrect`가 `true`로 변경되면서 다음 문제가 자동으로 줄어드는 버그 발생.
- 결과 페이지에 도달하지 못하거나 잘못된 결과(0/2로 계산)가 표시되는 문제 발생.

### 상태 변화와 시간의 흐름 간 단절

- 상태를 "현재 한 번의 스냅샷"으로만 보고 이를 기반으로 로직을 계산하려 했던 것이 문제의 핵심.
- 상태 변화의 연속성과 이벤트 축적의 개념이 부족했음.

---

## 해결 방법

### 시간의 흐름을 반영한 설계로 전환

- 상태는 특정 시점의 정적인 정보가 아니라, **이벤트의 축적을 통해 계산된 결과**로 봐야 한다고 판단했습니다.
- 이를 기반으로 **이벤트 기반 아키텍처**를 도입했습니다.

### 이벤트를 기반으로 상태 계산

- 각 사용자 액션을 이벤트로 정의:
  - `submit_answer`: 사용자가 답을 제출했음을 기록
  - `response_question_result`: 서버 응답을 이벤트로 처리
  - `retry_quiz`: 틀린 문제만 다시 출제
- 이벤트가 발생할 때마다 이를 누적하고, 상태는 이벤트를 해석한 결과로 계산

### 정확한 로직과 상태 흐름 보장

- 문제 풀이 → 정답 제출 → 결과 계산 → 다시 풀기 흐름이 명확해지도록 설계했습니다.

```typescript
import type React from 'react';

type QuestionData = {
  questionId: string;
};

type DomainEvent =
  | {
      type: 'download_quiz';
      questions: QuestionData[];
    }
  | {
      type: 'submit_answer';
      questionId: string;
      answer: string;
    }
  | {
      type: 'response_question_result';
      questionId: string;
      ok: boolean;
    }
  | {
      type: 'end_quiz';
    }
  | {
      type: 'retry_quiz';
    };

type QuestionState = {
  questionId: string;
  status: 'ready' | 'submitting' | 'correct' | 'wrong';
};

type State = {
  questions: QuestionState[];
};

// 이벤트 기반 상태 계산 로직
const reducer: React.Reducer<State, DomainEvent> = (prevState, event) => {
  switch (event.type) {
    case 'download_quiz': {
      return {
        questions: event.questions.map((question) => ({
          questionId: question.questionId,
          status: 'ready',
        })),
      };
    }

    case 'submit_answer': {
      return {
        questions: prevState.questions.map((question) => {
          if (question.questionId === event.questionId) {
            return {
              questionId: question.questionId,
              status: 'submitting',
            };
          }
          return question;
        }),
      };
    }

    case 'response_question_result': {
      return {
        questions: prevState.questions.map((question) => {
          if (question.questionId === event.questionId) {
            return {
              questionId: question.questionId,
              status: event.ok ? 'correct' : 'wrong',
            };
          }
          return question;
        }),
      };
    }

    case 'end_quiz': {
      if (prevState.questions.filter((q) => q.status === 'ready').length > 0) {
        return prevState;
      }

      return {
        questions: prevState.questions.filter((q) => q.status !== 'correct'),
      };
    }

    case 'retry_quiz': {
      return prevState;
    }
  }
};
```

---

## Finite State Machine과의 연결

### 상태 흐름 정의

- 각 질문이 명확한 상태를 가지도록 설계:
  ```text
  ready → submitting → correct/wrong
  ```

### FSM을 통해 로직의 명확성과 일관성 보장

- 상태 변화의 흐름을 Finite State Machine 방식으로 정의하여 복잡한 로직을 단순화했습니다.

---

## 성과

- **문제 개수 감소 및 결과 계산 오류 해결**: 상태 관리 방식 개선으로 버그 해결
- **UX 개선**: 진행 상태가 직관적으로 표시되고, 결과 계산의 정확도 향상
- **유지보수성 향상**: 새로운 로직 추가 시 기존 코드 변경량 최소화

---

## 시각 자료

### 이벤트 플로우 다이어그램

```text
download_quiz → submit_answer → response_question_result → end_quiz → retry_quiz
```

<!-- ![이벤트 흐름 다이어그램](path/to/event-flow-diagram.png) -->

### 상태 변화 다이어그램

```text
ready → submitting → correct/wrong
```

<!-- ![상태 변화 다이어그램](path/to/state-diagram.png) -->

### Before/After 비교

#### Before

- `isCorrect` 사용으로 인해 문제 개수가 줄어들고, 결과 계산이 잘못된 화면:
  <!-- ![Before 화면](path/to/before-screenshot.png) -->

#### After

- 이벤트 기반 설계 후 문제 풀이 → 결과 페이지 → 다시 풀기 과정:
  <!-- ![After GIF](path/to/after-gif.gif) -->

---

## 배운 점

### 이벤트 기반 설계의 가치

- 단순한 상태 관리의 한계를 극복하고, **이벤트 축적이 현재 상태를 만든다**는 개념을 배웠습니다.
- 상태를 시간의 흐름으로 바라보는 접근 방식은 복잡한 비즈니스 로직에서도 일관성을 유지할 수 있도록 도와줍니다.
