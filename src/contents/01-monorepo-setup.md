---
id: 1
title: '[오픈소스 개발기] 모노레포 도입하기'
date: 2024-10-12 15:00:00
category: developments
thumbnail: '/images/thumbnail/monorepo.jpg'
draft: false
---

처음 BIENGUAL 프로젝트에서 오픈소스 라이브러리를 개발하게 되었을 때, 사실 모노레포라는 개념조차 생소했습니다. 단순히 CRA(create-react-app)로 데모와 라이브러리를 한꺼번에 개발하려다 보니 수정한 뒤 `npm`에 배포하고, 데모 프로젝트에서 설치해 테스트하는 **비효율적인 작업**을 반복했습니다.

모노레포라는 접근 방식이 있다는 것을 알게 되고 나서, "왜 이걸 더 일찍 시작하지 않았을까?"라는 생각이 들었습니다. 이번 글에서는 **모노레포를 도입하면서 경험한 시행착오와 배운 점**을 공유하고자 합니다.

---

## 모노레포를 도입한 이유

모노레포는 **여러 패키지나 프로젝트를 하나의 레포지토리에서 관리**하는 방식을 뜻합니다. 이를 통해 각 패키지 간의 의존성을 명확히 관리하고, 코드 변경 사항을 중앙에서 통합적으로 처리할 수 있습니다.

저희 프로젝트에서는 다음과 같은 이유로 모노레포를 도입했습니다:

- **개발 효율성 증가**:  
  라이브러리(`core`)와 데모(`demo`)를 분리하여, 라이브러리를 수정한 뒤 별도로 `npm publish` 없이 바로 데모에서 테스트할 수 있는 환경이 필요했습니다.

- **중복된 설정 제거**:  
  ESLint, Prettier, Typescript 같은 공통 도구를 루트에서 관리함으로써 중복 설정을 줄이고 유지보수를 단순화할 수 있었습니다.

- **의존성 관리 개선**:  
  각 패키지에서 필요한 의존성을 명확히 구분하고, 공통 의존성은 루트에서 통합 관리할 수 있었습니다.

---

## 막막하기만 한 모노레포

솔직히 말하면, 처음에는 CRA로 시작한 프로젝트에서 데모와 라이브러리를 어떻게 나눠야 하는지도 몰랐습니다. 라이브러리 수정 → `npm publish` → 데모에서 테스트를 반복하며, "이게 맞는 방법일까?"라는 생각이 들었죠.

이 과정에서 **Yarn Workspaces**를 알게 되었고, 모노레포 환경으로 전환하게 되었습니다.

---

## 모노레포를 구축하며 겪은 시행착오

### 1. Yarn Workspaces 설정의 이해 부족

모노레포를 구성하기 위해 Yarn Workspaces를 선택했지만, 초반에는 각 패키지와 루트 간 설정의 상호작용을 제대로 이해하지 못해 문제가 발생했습니다.

- **Typescript 문제**:  
  루트에 Typescript를 설치했음에도, 각 워크스페이스(`core`, `demo`)에서 별도로 Typescript를 설치해야 했습니다. 이는 Yarn Workspaces가 워크스페이스별로 종속성을 격리하기 때문인데, 이 동작 방식을 이해하기까지 시간이 걸렸습니다.

- **의존성 문제**:  
  루트에서 `react`를 설치했는데, `demo`에서 React 관련 오류가 발생했습니다. 이는 `peerDependencies`를 제대로 설정하지 않아 발생한 문제였습니다. 해결을 위해 `core`의 `package.json`에 다음과 같이 `peerDependencies`를 명시했습니다:

```json
"peerDependencies": {
  "react": ">=16.8.0 <19.0.0",
  "react-dom": ">=16.8.0 <19.0.0"
}
```

이후 각 패키지 간의 종속성을 명확히 구분하고 관리할 수 있었습니다.

---

### 2. 빌드 시스템 전환: esbuild 도입

CRA에서 벗어나면서 가장 큰 과제는 **번들 크기를 최소화하고 빌드 속도를 최적화하는 것**이었습니다. 여기서 `esbuild`를 사용해 직접 빌드 스크립트를 작성하게 되었습니다.

```javascript
import esbuild from 'esbuild';

esbuild
  .build({
    entryPoints: ['src/index.ts'],
    bundle: true,
    outfile: 'dist/index.js',
    format: 'esm',
    minify: true,
  })
  .catch(() => process.exit(1));
```

번들링 과정을 직접 관리하면서, 라이브러리 개발에서 번들 크기와 빌드 속도가 사용자 경험에 직접적으로 영향을 미친다는 점을 체감했습니다. 특히, `esbuild`의 빠른 속도 덕분에 개발 중 생산성을 크게 향상시킬 수 있었습니다.

---

### 3. CI/CD로 작업 자동화

GitHub Actions를 활용해 CI/CD 환경을 구축하면서 생산성을 극대화했습니다.

- **Lint 및 Type Check 자동화**:  
  코드 퀄리티를 유지하기 위해 ESLint와 Typescript 검사를 자동으로 실행하도록 설정했습니다.

- **npm 자동 배포**:  
  `main` 브랜치에 머지되면, 라이브러리가 자동으로 `npm`에 배포되도록 설정했습니다.

```yaml
# GitHub Actions: npm 배포
jobs:
  publish:
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Install dependencies
        run: yarn install
      - name: Build core
        working-directory: ./core
        run: yarn build
      - name: Publish to npm
        working-directory: ./core
        run: npm publish
```

자동화는 배포 실수를 줄이고 작업 시간을 절약하는 데 크게 기여했습니다.

---

## 모노레포로 얻은 교훈

### 1. 효율적인 작업 환경이 생산성을 높인다

모노레포로 전환한 이후, 라이브러리 수정 후 바로 데모에서 테스트할 수 있는 환경이 구축되면서 작업 속도가 크게 향상되었습니다. 각 패키지가 동일한 레포지토리에서 관리되므로 수정 사항이 즉각 반영되어, 반복 작업을 줄일 수 있었습니다.

### 2. 자동화는 필수다

CI/CD를 통해 배포 실수를 줄이고 작업 시간을 절약할 수 있었습니다. 이는 작은 프로젝트에서도 충분히 가치 있는 작업이었습니다.

### 3. 시행착오는 성장의 기회다

모노레포 구축 과정에서 번들링, CI/CD, 의존성 관리 등 다양한 기술을 깊이 있게 배울 수 있었습니다. 이 과정에서 시행착오는 단순한 어려움이 아니라 성장의 계기가 되었음을 느꼈습니다.

---

## 결론

모노레포를 도입하며 효율적인 작업 환경을 구축하는 것의 중요성을 알게 되었습니다. 처음엔 복잡하고 어렵게 느껴졌지만, 결과적으로 작업의 흐름과 협업의 질을 모두 높이는 데 큰 도움이 되었습니다.
